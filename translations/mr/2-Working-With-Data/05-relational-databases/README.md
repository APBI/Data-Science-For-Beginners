<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "11b166fbcb7eaf82308cdc24b562f687",
  "translation_date": "2025-09-04T16:43:54+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "mr"
}
-->
# डेटा सोबत काम करणे: रिलेशनल डेटाबेस

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| डेटा सोबत काम करणे: रिलेशनल डेटाबेस - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

तुम्ही पूर्वी माहिती साठवण्यासाठी स्प्रेडशीट वापरले असेल अशी शक्यता आहे. तुम्हाला पंक्ती आणि स्तंभांचा संच होता, जिथे पंक्तीमध्ये माहिती (किंवा डेटा) होती आणि स्तंभांनी त्या माहितीचे वर्णन केले (कधीकधी मेटाडेटा म्हणतात). रिलेशनल डेटाबेस हा टेबल्समधील पंक्ती आणि स्तंभांच्या या मुख्य तत्त्वावर आधारित असतो, ज्यामुळे तुम्हाला माहिती अनेक टेबल्समध्ये विभागून ठेवता येते. यामुळे तुम्हाला अधिक जटिल डेटा हाताळता येतो, पुनरावृत्ती टाळता येते आणि डेटा एक्सप्लोर करण्याच्या पद्धतींमध्ये लवचिकता मिळते. चला रिलेशनल डेटाबेसच्या संकल्पना समजून घेऊया.

## [पूर्व-व्याख्यान प्रश्नमंजुषा](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/8)

## सर्व काही टेबल्सपासून सुरू होते

रिलेशनल डेटाबेसचा मुख्य भाग म्हणजे टेबल्स. स्प्रेडशीटप्रमाणेच, टेबल म्हणजे स्तंभ आणि पंक्तींचा संग्रह असतो. पंक्तीमध्ये आपण काम करू इच्छित असलेला डेटा किंवा माहिती असते, जसे की शहराचे नाव किंवा पावसाचे प्रमाण. स्तंभ त्या डेटा बद्दल माहिती देतात.

चला शहरांबद्दल माहिती साठवण्यासाठी एक टेबल तयार करून सुरुवात करूया. आपण त्यांच्या नाव आणि देशासह सुरुवात करू शकतो. तुम्ही हे टेबलमध्ये खालीलप्रमाणे साठवू शकता:

| शहर      | देश            |
| -------- | ------------- |
| टोकियो   | जपान          |
| अटलांटा  | युनायटेड स्टेट्स |
| ऑकलंड    | न्यूझीलंड      |

लक्षात घ्या की **शहर**, **देश** आणि **लोकसंख्या** हे स्तंभ डेटा साठवण्याचे वर्णन करतात आणि प्रत्येक पंक्तीमध्ये एका शहराची माहिती असते.

## एकाच टेबल पद्धतीची मर्यादा

वर दिलेले टेबल तुम्हाला परिचित वाटत असेल. चला आपल्या डेटाबेसमध्ये वार्षिक पावसाचा डेटा (मिलीमीटरमध्ये) जोडूया. आपण 2018, 2019 आणि 2020 या वर्षांवर लक्ष केंद्रित करूया. जर आपण टोकियोसाठी डेटा जोडला तर तो खालीलप्रमाणे दिसेल:

| शहर   | देश      | वर्ष | प्रमाण |
| ----- | ------- | ---- | ------ |
| टोकियो | जपान    | 2020 | 1690   |
| टोकियो | जपान    | 2019 | 1874   |
| टोकियो | जपान    | 2018 | 1445   |

आपण आमच्या टेबलमध्ये काय लक्षात घेतले? तुम्ही पाहू शकता की आम्ही शहराचे नाव आणि देश वारंवार पुनरावृत्ती करत आहोत. यामुळे बरीच स्टोरेज लागेल आणि अनेक प्रत असणे अनावश्यक आहे. शेवटी, टोकियोचे नाव एकच आहे जे आपल्याला आवश्यक आहे.

ठीक आहे, काहीतरी वेगळे करून पाहूया. प्रत्येक वर्षासाठी नवीन स्तंभ जोडूया:

| शहर      | देश            | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| टोकियो   | जपान          | 1445 | 1874 | 1690 |
| अटलांटा  | युनायटेड स्टेट्स | 1779 | 1111 | 1683 |
| ऑकलंड    | न्यूझीलंड      | 1386 | 942  | 1176 |

यामुळे पंक्तींची पुनरावृत्ती टाळली जाते, परंतु काही इतर आव्हाने निर्माण होतात. प्रत्येक वेळी नवीन वर्ष आल्यावर आपल्याला टेबलची रचना बदलावी लागेल. याशिवाय, आपला डेटा वाढत असताना वर्षे स्तंभ म्हणून ठेवणे मूल्ये मिळवणे आणि गणना करणे कठीण होईल.

यामुळे आपल्याला एकाधिक टेबल्स आणि नातेसंबंधांची आवश्यकता आहे. आपला डेटा विभागून आपण पुनरावृत्ती टाळू शकतो आणि डेटा हाताळण्याच्या पद्धतींमध्ये अधिक लवचिकता मिळवू शकतो.

## नातेसंबंधांची संकल्पना

चला आपल्या डेटावर परत जाऊया आणि ते कसे विभागायचे ते ठरवूया. आपल्याला शहरांचे नाव आणि देश साठवायचे आहे, त्यामुळे हे एका टेबलमध्ये चांगले काम करेल.

| शहर      | देश            |
| -------- | ------------- |
| टोकियो   | जपान          |
| अटलांटा  | युनायटेड स्टेट्स |
| ऑकलंड    | न्यूझीलंड      |

पण पुढील टेबल तयार करण्यापूर्वी, आपल्याला प्रत्येक शहराचा संदर्भ कसा द्यायचा ते ठरवावे लागेल. आपल्याला काही प्रकारचा आयडेंटिफायर, आयडी किंवा (तांत्रिक डेटाबेस टर्म्समध्ये) प्राथमिक की आवश्यक आहे. प्राथमिक की म्हणजे टेबलमधील एका विशिष्ट पंक्तीला ओळखण्यासाठी वापरलेले मूल्य. हे स्वतःच्या मूल्यावर आधारित असू शकते (उदाहरणार्थ, आपण शहराचे नाव वापरू शकतो), परंतु ते नेहमीच एक नंबर किंवा इतर आयडेंटिफायर असावे. आयडी कधीही बदलू नये कारण ते नातेसंबंध बिघडवेल. बहुतेक प्रकरणांमध्ये प्राथमिक की किंवा आयडी एक ऑटो-जनरेटेड नंबर असेल.

> ✅ प्राथमिक कीला वारंवार PK म्हणून संक्षेपित केले जाते

### शहर

| शहर_आयडी | शहर      | देश            |
| -------- | -------- | ------------- |
| 1        | टोकियो   | जपान          |
| 2        | अटलांटा  | युनायटेड स्टेट्स |
| 3        | ऑकलंड    | न्यूझीलंड      |

> ✅ तुम्ही लक्षात घ्याल की आम्ही या धड्यात "आयडी" आणि "प्राथमिक की" या संज्ञा परस्पर बदलून वापरतो. येथे दिलेली संकल्पना डेटा फ्रेम्ससाठी लागू होते, ज्याचा तुम्ही नंतर अभ्यास कराल. डेटा फ्रेम्स "प्राथमिक की" ही संज्ञा वापरत नाहीत, परंतु तुम्ही पाहाल की त्या जवळजवळ त्याच प्रकारे वागतात.

आपले शहरांचे टेबल तयार झाल्यावर, चला पावसाचा डेटा साठवूया. शहराची संपूर्ण माहिती पुनरावृत्ती करण्याऐवजी, आपण आयडी वापरू शकतो. आपण नव्याने तयार केलेल्या टेबलमध्ये *आयडी* कॉलम असणे देखील सुनिश्चित करावे, कारण सर्व टेबल्समध्ये आयडी किंवा प्राथमिक की असावी.

### पाऊस

| पाऊस_आयडी | शहर_आयडी | वर्ष | प्रमाण |
| --------- | -------- | ---- | ------ |
| 1         | 1        | 2018 | 1445   |
| 2         | 1        | 2019 | 1874   |
| 3         | 1        | 2020 | 1690   |
| 4         | 2        | 2018 | 1779   |
| 5         | 2        | 2019 | 1111   |
| 6         | 2        | 2020 | 1683   |
| 7         | 3        | 2018 | 1386   |
| 8         | 3        | 2019 | 942    |
| 9         | 3        | 2020 | 1176   |

लक्षात घ्या की **शहर_आयडी** कॉलम नव्याने तयार केलेल्या **पाऊस** टेबलमध्ये आहे. या कॉलममध्ये **शहर** टेबलमधील आयडी संदर्भित करणारी मूल्ये आहेत. तांत्रिक रिलेशनल डेटा टर्म्समध्ये, याला **फॉरेन की** म्हणतात; हे दुसऱ्या टेबलमधील प्राथमिक की आहे. तुम्ही याला फक्त संदर्भ किंवा पॉइंटर म्हणून विचार करू शकता. **शहर_आयडी** 1 टोकियोला संदर्भित करते.

> [!NOTE] फॉरेन कीला वारंवार FK म्हणून संक्षेपित केले जाते

## डेटा मिळवणे

आपला डेटा दोन टेबल्समध्ये विभागलेला असल्याने, तुम्हाला कदाचित आश्चर्य वाटेल की तो कसा मिळवायचा. जर आपण MySQL, SQL Server किंवा Oracle सारखा रिलेशनल डेटाबेस वापरत असाल, तर आपण Structured Query Language किंवा SQL नावाची भाषा वापरू शकतो. SQL (कधीकधी sequel असे उच्चारले जाते) ही रिलेशनल डेटाबेसमधील डेटा मिळवण्यासाठी आणि बदलण्यासाठी वापरली जाणारी मानक भाषा आहे.

डेटा मिळवण्यासाठी तुम्ही `SELECT` कमांड वापरता. त्याच्या मुख्य भागात, तुम्ही **select** करतो ते स्तंभ तुम्हाला पाहायचे आहेत आणि **from** करतो ते टेबल जिथे ते आहेत. जर तुम्हाला फक्त शहरांची नावे दाखवायची असतील, तर तुम्ही खालीलप्रमाणे करू शकता:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` मध्ये तुम्ही स्तंभांची यादी करता, आणि `FROM` मध्ये तुम्ही टेबलची यादी करता.

> [NOTE] SQL सिंटॅक्स केस-इन्सेन्सिटिव्ह आहे, म्हणजे `select` आणि `SELECT` एकसारखे आहेत. तथापि, तुम्ही वापरत असलेल्या डेटाबेसच्या प्रकारानुसार स्तंभ आणि टेबल्स केस सेंसिटिव्ह असू शकतात. परिणामी, प्रोग्रामिंगमध्ये सर्वकाही केस सेंसिटिव्ह असल्यासारखे मानणे ही सर्वोत्तम पद्धत आहे. SQL क्वेरी लिहिताना सामान्य प्रथा म्हणजे कीवर्ड्स सर्व कॅपिटल अक्षरांमध्ये लिहिणे.

वरील क्वेरी सर्व शहरांचे प्रदर्शन करेल. कल्पना करा की आपल्याला फक्त न्यूझीलंडमधील शहरांचे प्रदर्शन करायचे आहे. आपल्याला काही प्रकारचे फिल्टर आवश्यक आहे. यासाठी SQL कीवर्ड `WHERE` आहे, म्हणजे "जिथे काहीतरी खरे आहे".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## डेटा जोडणे

आत्तापर्यंत आपण एका टेबलमधून डेटा मिळवला आहे. आता आपल्याला **शहर** आणि **पाऊस** या दोन्ही टेबल्समधील डेटा एकत्र आणायचा आहे. हे त्यांना *जोडून* केले जाते. तुम्ही मूलत: दोन टेबल्समध्ये सीम तयार कराल आणि प्रत्येक टेबलमधील कॉलममधील मूल्ये जुळवाल.

आपल्या उदाहरणात, आम्ही **पाऊस** मधील **शहर_आयडी** कॉलमला **शहर** मधील **शहर_आयडी** कॉलमशी जुळवू. यामुळे पावसाचे मूल्य त्याच्या संबंधित शहराशी जुळेल. आपण करणार असलेला जोड हा *इनर* जोड आहे, म्हणजे जर कोणत्याही पंक्ती दुसऱ्या टेबलमधील कोणत्याही गोष्टीशी जुळत नसतील तर त्या प्रदर्शित केल्या जाणार नाहीत. आमच्या बाबतीत प्रत्येक शहराला पाऊस आहे, त्यामुळे सर्व काही प्रदर्शित होईल.

चला 2019 साठी सर्व शहरांचा पाऊस मिळवूया.

आम्ही हे टप्प्याटप्प्याने करू. पहिला टप्पा म्हणजे डेटा एकत्र जोडणे, सीमसाठी कॉलम्स दर्शवून - **शहर_आयडी** जसे आधी हायलाइट केले आहे.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

आम्ही दोन कॉलम्स हायलाइट केले आहेत आणि टेबल्स **शहर_आयडी** ने जोडायचे आहेत हे नमूद केले आहे. आता आम्ही `WHERE` स्टेटमेंट जोडू शकतो जे फक्त 2019 वर्ष फिल्टर करेल.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## सारांश

रिलेशनल डेटाबेस हे माहिती अनेक टेबल्समध्ये विभागण्यावर केंद्रित असतात, जे नंतर प्रदर्शन आणि विश्लेषणासाठी पुन्हा एकत्र आणले जाते. यामुळे गणना करण्यासाठी आणि अन्यथा डेटा हाताळण्यासाठी उच्च स्तराची लवचिकता मिळते. तुम्ही रिलेशनल डेटाबेसच्या मुख्य संकल्पना पाहिल्या आहेत आणि दोन टेबल्समध्ये जोड कसा करायचा ते शिकले आहे.

## 🚀 आव्हान

इंटरनेटवर अनेक रिलेशनल डेटाबेस उपलब्ध आहेत. तुम्ही वर शिकलेल्या कौशल्यांचा वापर करून डेटा एक्सप्लोर करू शकता.

## व्याख्यानानंतरची प्रश्नमंजुषा

## [व्याख्यानानंतरची प्रश्नमंजुषा](https://ff-quizzes.netlify.app/en/ds/)

## पुनरावलोकन आणि स्व-अभ्यास

SQL आणि रिलेशनल डेटाबेस संकल्पनांचा अभ्यास सुरू ठेवण्यासाठी [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) वर अनेक संसाधने उपलब्ध आहेत.

- [रिलेशनल डेटाच्या संकल्पना वर्णन करा](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Transact-SQL सह क्वेरी करणे सुरू करा](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL ही SQL ची आवृत्ती आहे)
- [Microsoft Learn वरील SQL सामग्री](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## असाइनमेंट

[असाइनमेंट शीर्षक](assignment.md)

---

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी कृपया लक्षात ठेवा की स्वयंचलित भाषांतरांमध्ये त्रुटी किंवा अचूकतेचा अभाव असू शकतो. मूळ भाषेतील दस्तऐवज हा अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर करून निर्माण होणाऱ्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.