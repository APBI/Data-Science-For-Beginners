<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9399d7b4767e75068f95ce5c660b285c",
  "translation_date": "2025-10-11T15:23:46+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "ta"
}
-->
# தரவுடன் வேலை செய்வது: தொடர்புடைய தரவுத்தொகுப்புகள்

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| தரவுடன் வேலை செய்வது: தொடர்புடைய தரவுத்தொகுப்புகள் - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

நீங்கள் முன்பு தகவல்களை சேமிக்க ஒரு ஸ்பிரெட்ஷீட்டை பயன்படுத்தியிருக்க வாய்ப்பு உள்ளது. அதில் வரிசைகள் மற்றும் நெடுவரிசைகள் இருந்தன, வரிசைகள் தகவல்களை (அல்லது தரவுகளை) கொண்டிருந்தன, மற்றும் நெடுவரிசைகள் தகவல்களை விவரித்தன (சில நேரங்களில் மெட்டாடேட்டா என்று அழைக்கப்படுகிறது). தொடர்புடைய தரவுத்தொகுப்பு இந்த அடிப்படை கொள்கை மீது கட்டமைக்கப்பட்டுள்ளது, இது பல அட்டவணைகளில் தகவல்களை பரப்ப அனுமதிக்கிறது. இது சிக்கலான தரவுகளுடன் வேலை செய்ய, மறு உருவாக்கத்தை தவிர்க்க, மற்றும் தரவுகளை ஆராய்வதில் நெகிழ்வுத்தன்மையை வழங்க உதவுகிறது. தொடர்புடைய தரவுத்தொகுப்பின் கருத்துக்களை ஆராய்வோம்.

## [முன்-வகுப்பு வினாடி வினா](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## இது அட்டவணைகளுடன் தொடங்குகிறது

ஒரு தொடர்புடைய தரவுத்தொகுப்பின் மையத்தில் அட்டவணைகள் உள்ளன. ஸ்பிரெட்ஷீட்டில் போலவே, ஒரு அட்டவணை நெடுவரிசைகள் மற்றும் வரிசைகளின் தொகுப்பாகும். வரிசை நாம் வேலை செய்ய விரும்பும் தரவுகளை அல்லது தகவல்களை கொண்டுள்ளது, உதாரணமாக ஒரு நகரத்தின் பெயர் அல்லது மழை அளவு. நெடுவரிசைகள் அவர்கள் சேமிக்கும் தரவுகளை விவரிக்கின்றன.

நகரங்கள் பற்றிய தகவல்களை சேமிக்க ஒரு அட்டவணையை தொடங்குவதன் மூலம் ஆராய்ச்சியை தொடங்குவோம். நாம் அவர்களின் பெயர் மற்றும் நாடு மூலம் தொடங்கலாம். இதை கீழே உள்ள அட்டவணையில் சேமிக்கலாம்:

| நகரம்     | நாடு          |
| -------- | ------------- |
| டோக்கியோ    | ஜப்பான்         |
| அட்லாண்டா  | அமெரிக்கா      |
| ஆக்க்லாந்து | நியூசிலாந்து   |

**நகரம்**, **நாடு** மற்றும் **மக்கள் தொகை** ஆகிய நெடுவரிசை பெயர்கள் சேமிக்கப்படும் தரவுகளை விவரிக்கின்றன, மற்றும் ஒவ்வொரு வரிசையும் ஒரு நகரம் பற்றிய தகவல்களை கொண்டுள்ளது.

## ஒற்றை அட்டவணை அணுகுமுறையின் குறைகள்

மேலே உள்ள அட்டவணை உங்களுக்கு மிகவும் பரிச்சயமாக தோன்ற வாய்ப்பு உள்ளது. நமது வளர்ந்து வரும் தரவுத்தொகுப்பில் கூடுதல் தரவுகளைச் சேர்ப்பதன் மூலம் தொடங்குவோம் - வருடாந்திர மழை அளவு (மில்லிமீட்டரில்). 2018, 2019 மற்றும் 2020 ஆண்டுகளை மையமாகக் கொண்டு கவனம் செலுத்துவோம். டோக்கியோவுக்கான தரவுகளைச் சேர்த்தால், அது இவ்வாறு தோன்றும்:

| நகரம்  | நாடு   | ஆண்டு | அளவு  |
| ----- | ------- | ---- | ------ |
| டோக்கியோ | ஜப்பான்   | 2020 | 1690   |
| டோக்கியோ | ஜப்பான்   | 2019 | 1874   |
| டோக்கியோ | ஜப்பான்   | 2018 | 1445   |

நமது அட்டவணையைப் பற்றி நீங்கள் என்ன கவனிக்கிறீர்கள்? நகரத்தின் பெயர் மற்றும் நாட்டை மீண்டும் மீண்டும் மறு உருவாக்குகிறோம் என்பதை நீங்கள் கவனிக்கலாம். இது மிகவும் சேமிப்பிடத்தை எடுத்துக்கொள்ளும், மேலும் பல முறை நகலெடுக்க வேண்டிய அவசியம் இல்லை. டோக்கியோவுக்கு நாங்கள் ஆர்வமாக உள்ள ஒரே பெயர் மட்டுமே உள்ளது.

சரி, வேறு ஒன்றை முயற்சிப்போம். ஒவ்வொரு ஆண்டிற்கும் புதிய நெடுவரிசைகளைச் சேர்ப்போம்:

| நகரம்     | நாடு          | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| டோக்கியோ    | ஜப்பான்         | 1445 | 1874 | 1690 |
| அட்லாண்டா  | அமெரிக்கா      | 1779 | 1111 | 1683 |
| ஆக்க்லாந்து | நியூசிலாந்து   | 1386 | 942  | 1176 |

இது வரிசை மறு உருவாக்கத்தைத் தவிர்க்கிறது, ஆனால் சில சவால்களைச் சேர்க்கிறது. ஒவ்வொரு முறையும் புதிய ஆண்டு வந்தால், நமது அட்டவணையின் அமைப்பை மாற்ற வேண்டும். மேலும், நமது தரவுகள் வளரும்போது, ஆண்டுகளை நெடுவரிசைகளாக வைத்திருப்பது மதிப்புகளை மீட்டெடுக்கவும் கணக்கிடவும் சிக்கலாக இருக்கும்.

இதனால் நமக்கு பல அட்டவணைகள் மற்றும் உறவுகள் தேவை. நமது தரவுகளை பிரிப்பதன் மூலம் மறு உருவாக்கத்தைத் தவிர்க்கவும், மற்றும் நமது தரவுகளுடன் வேலை செய்ய நெகிழ்வுத்தன்மையை பெறலாம்.

## உறவுகளின் கருத்துக்கள்

நமது தரவுகளுக்கு திரும்பி, அதை எப்படி பிரிக்க வேண்டும் என்பதை தீர்மானிக்கலாம். நகரங்களுக்கான பெயர் மற்றும் நாட்டை சேமிக்க விரும்புகிறோம், எனவே இது ஒரு அட்டவணையில் சிறந்த முறையில் வேலை செய்யும்.

| நகரம்     | நாடு          |
| -------- | ------------- |
| டோக்கியோ    | ஜப்பான்         |
| அட்லாண்டா  | அமெரிக்கா      |
| ஆக்க்லாந்து | நியூசிலாந்து   |

ஆனால் அடுத்த அட்டவணையை உருவாக்குவதற்கு முன், ஒவ்வொரு நகரத்தையும் எப்படி குறிப்பிட வேண்டும் என்பதை கண்டறிய வேண்டும். நமக்கு ஒரு வகையான அடையாளம், ID அல்லது (தொழில்நுட்ப தரவுத்தொகுப்பு வார்த்தைகளில்) ஒரு முதன்மை விசை தேவை. ஒரு முதன்மை விசை என்பது ஒரு அட்டவணையில் ஒரு குறிப்பிட்ட வரிசையை அடையாளம் காண பயன்படுத்தப்படும் மதிப்பு. இது ஒரு மதிப்பின் அடிப்படையில் இருக்கலாம் (உதாரணமாக நகரத்தின் பெயரை பயன்படுத்தலாம்), ஆனால் இது பெரும்பாலும் ஒரு எண் அல்லது பிற அடையாளமாக இருக்க வேண்டும். ID ஒருபோதும் மாறக்கூடாது, ஏனெனில் இது உறவுகளை உடைக்கும். பெரும்பாலான சந்தர்ப்பங்களில் முதன்மை விசை அல்லது ID ஒரு தானாக உருவாக்கப்படும் எண்ணாக இருக்கும்.

> ✅ முதன்மை விசை அடிக்கடி PK என்று சுருக்கமாக குறிப்பிடப்படுகிறது

### cities

| city_id | நகரம்     | நாடு          |
| ------- | -------- | ------------- |
| 1       | டோக்கியோ    | ஜப்பான்         |
| 2       | அட்லாண்டா  | அமெரிக்கா      |
| 3       | ஆக்க்லாந்து | நியூசிலாந்து   |

> ✅ இந்த பாடத்தில் "id" மற்றும் "முதன்மை விசை" என்ற வார்த்தைகளை பரிமாற்றமாக பயன்படுத்துகிறோம் என்பதை நீங்கள் கவனிப்பீர்கள். இங்கு உள்ள கருத்துக்கள் DataFrames-க்கு பொருந்தும், அதை நீங்கள் பின்னர் ஆராய்வீர்கள். DataFrames "முதன்மை விசை" என்ற வார்த்தையை பயன்படுத்தாது, ஆனால் அவை அதே விதமாக செயல்படுவதை நீங்கள் கவனிப்பீர்கள்.

நமது cities அட்டவணையை உருவாக்கிய பிறகு, மழை அளவை சேமிப்போம். நகரம் பற்றிய முழு தகவல்களை மறு உருவாக்குவதற்குப் பதிலாக, ID ஐ பயன்படுத்தலாம். மேலும், புதிய அட்டவணை *id* நெடுவரிசை கொண்டிருக்க வேண்டும் என்பதை உறுதிப்படுத்த வேண்டும், ஏனெனில் அனைத்து அட்டவணைகளும் id அல்லது முதன்மை விசை கொண்டிருக்க வேண்டும்.

### rainfall

| rainfall_id | city_id | ஆண்டு | அளவு  |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

புதிய **rainfall** அட்டவணையின் உள்ளே உள்ள **city_id** நெடுவரிசையை கவனிக்கவும். இந்த நெடுவரிசை **cities** அட்டவணையில் உள்ள ID களை குறிப்பிடும் மதிப்புகளை கொண்டுள்ளது. தொழில்நுட்ப தொடர்புடைய தரவுத்தொகுப்பு வார்த்தைகளில், இது **வெளிநாட்டு விசை** என்று அழைக்கப்படுகிறது; இது மற்றொரு அட்டவணையில் இருந்து ஒரு முதன்மை விசை. நீங்கள் இதை ஒரு குறிப்பாக அல்லது பாயிண்டராக நினைக்கலாம். **city_id** 1 டோக்கியோவை குறிப்பிடுகிறது.

> [!NOTE] வெளிநாட்டு விசை அடிக்கடி FK என்று சுருக்கமாக குறிப்பிடப்படுகிறது

## தரவுகளை மீட்டெடுப்பது

நமது தரவுகளை இரண்டு அட்டவணைகளில் பிரித்த பிறகு, அதை எப்படி மீட்டெடுப்பது என்று நீங்கள் ஆச்சரியப்படலாம். MySQL, SQL Server அல்லது Oracle போன்ற தொடர்புடைய தரவுத்தொகுப்பைப் பயன்படுத்தினால், Structured Query Language அல்லது SQL என்ற மொழியைப் பயன்படுத்தலாம். SQL (சில நேரங்களில் sequel என்று உச்சரிக்கப்படுகிறது) என்பது தொடர்புடைய தரவுத்தொகுப்பில் தரவுகளை மீட்டெடுக்கவும் மாற்றவும் பயன்படுத்தப்படும் ஒரு நிலையான மொழியாகும்.

தரவுகளை மீட்டெடுக்க நீங்கள் `SELECT` கட்டளையைப் பயன்படுத்துகிறீர்கள். அதன் மையத்தில், நீங்கள் **தேர்ந்தெடுக்க** விரும்பும் நெடுவரிசைகளை **அவை உள்ள அட்டவணையிலிருந்து** குறிப்பிடுகிறீர்கள். நகரங்களின் பெயர்களை மட்டும் காட்ட விரும்பினால், நீங்கள் பின்வருமாறு பயன்படுத்தலாம்:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` என்பது நீங்கள் பட்டியலிட விரும்பும் நெடுவரிசைகள் இருக்கும் இடம், மற்றும் `FROM` என்பது அட்டவணைகளை பட்டியலிடும் இடம்.

> [NOTE] SQL சyntax case-insensitive ஆகும், அதாவது `select` மற்றும் `SELECT` ஒரே பொருள் கொண்டவை. ஆனால், நீங்கள் பயன்படுத்தும் தரவுத்தொகுப்பின் வகையைப் பொறுத்து நெடுவரிசைகள் மற்றும் அட்டவணைகள் case-sensitive ஆக இருக்கலாம். எனவே, நிரலாக்கத்தில் எல்லாவற்றையும் case-sensitive ஆக இருப்பதாக எப்போதும் கருதுவது சிறந்த நடைமுறையாகும். SQL கேள்விகளை எழுதும்போது, பொதுவாக முக்கிய வார்த்தைகளை முழு capital எழுத்துக்களில் எழுதுவது வழக்கம்.

மேலே உள்ள கேள்வி அனைத்து நகரங்களையும் காட்டும். நியூசிலாந்தில் உள்ள நகரங்களை மட்டும் காட்ட விரும்பினால், ஒரு வகையான வடிகட்டல் தேவை. SQL முக்கிய வார்த்தை `WHERE`, அல்லது "எதாவது உண்மையாக இருக்கும் இடம்".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## தரவுகளை இணைப்பது

இப்போது வரை, நாங்கள் ஒரு அட்டவணையிலிருந்து தரவுகளை மீட்டெடுத்துள்ளோம். இப்போது **cities** மற்றும் **rainfall** ஆகியவற்றிலிருந்து தரவுகளை ஒன்றாகக் கொண்டு வர விரும்புகிறோம். இது அவற்றை *இணைப்பதன்* மூலம் செய்யப்படுகிறது. நீங்கள் இரண்டு அட்டவணைகளுக்கு இடையில் ஒரு seam உருவாக்கி, ஒவ்வொரு அட்டவணையிலிருந்து ஒரு நெடுவரிசையின் மதிப்புகளை பொருத்துவீர்கள்.

எங்கள் உதாரணத்தில், **rainfall** இல் உள்ள **city_id** நெடுவரிசையை **cities** இல் உள்ள **city_id** நெடுவரிசையுடன் பொருத்துவோம். இது மழை அளவுகளை அதன் தொடர்புடைய நகரத்துடன் பொருத்தும். நாம் செய்யும் இணைப்பு வகை *உள்ளக* இணைப்பு என்று அழைக்கப்படுகிறது, அதாவது மற்ற அட்டவணையிலிருந்து எந்த வரிசைகளும் பொருந்தவில்லை என்றால் அவை காட்டப்படாது. எங்கள் சந்தர்ப்பத்தில் ஒவ்வொரு நகரத்துக்கும் மழை அளவு உள்ளது, எனவே எல்லாம் காட்டப்படும்.

எங்கள் நகரங்களுக்கான 2019 மழை அளவுகளை மீட்டெடுக்கலாம்.

நாம் இதை படிகளில் செய்யப் போகிறோம். முதல் படி, **city_id** என முன்னதாகக் குறிப்பிடப்பட்ட நெடுவரிசைகளை seam க்கான நெடுவரிசைகளாகக் குறிப்பிடுவதன் மூலம் தரவுகளை இணைப்பது.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

நாம் இரண்டு நெடுவரிசைகளை, மற்றும் **city_id** மூலம் அட்டவணைகளை இணைக்க விரும்புகிறோம் என்பதை குறிப்பிடுகிறோம். இப்போது `WHERE` அறிக்கையைச் சேர்த்து 2019 ஆண்டை மட்டும் வடிகட்டலாம்.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## சுருக்கம்

தொடர்புடைய தரவுத்தொகுப்புகள் தகவல்களை பல அட்டவணைகளுக்கு இடையில் பிரிப்பதை மையமாகக் கொண்டுள்ளன, பின்னர் அவற்றை திரும்பக் கொண்டு வந்து காட்சிப்படுத்தவும் பகுப்பாய்வு செய்யவும். இது கணக்கீடுகள் செய்யவும், மற்றும் தரவுகளை மாற்றவும் அதிக நெகிழ்வுத்தன்மையை வழங்குகிறது. தொடர்புடைய தரவுத்தொகுப்பின் முக்கிய கருத்துக்களை, மற்றும் இரண்டு அட்டவணைகளுக்கு இடையில் இணைப்பை எப்படி செய்ய வேண்டும் என்பதை நீங்கள் பார்த்துள்ளீர்கள்.

## 🚀 சவால்

இணையத்தில் பல தொடர்புடைய தரவுத்தொகுப்புகள் கிடைக்கின்றன. நீங்கள் மேலே கற்றுக்கொண்ட திறன்களைப் பயன்படுத்தி தரவுகளை ஆராயலாம்.

## வகுப்புக்குப் பின் வினாடி வினா

## [வகுப்புக்குப் பின் வினாடி வினா](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## மதிப்பீடு & சுயபடிப்பு

SQL மற்றும் தொடர்புடைய தரவுத்தொகுப்பு கருத்துக்களை தொடர்ந்து ஆராய Microsoft Learn இல் பல வளங்கள் கிடைக்கின்றன

- [தொடர்புடைய தரவின் கருத்துக்களை விவரிக்கவும்](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Transact-SQL உடன் கேள்விகளை தொடங்கவும்](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL என்பது SQL இன் ஒரு பதிப்பு)
- [Microsoft Learn இல் SQL உள்ளடக்கம்](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## பணிக்கட்டளை

[பணிக்கட்டளை தலைப்பு](assignment.md)

---

**குறிப்பு**:  
இந்த ஆவணம் [Co-op Translator](https://github.com/Azure/co-op-translator) என்ற AI மொழிபெயர்ப்பு சேவையை பயன்படுத்தி மொழிபெயர்க்கப்பட்டுள்ளது. எங்கள் நோக்கம் துல்லியமாக இருக்க வேண்டும் என்றாலும், தானியங்கி மொழிபெயர்ப்புகளில் பிழைகள் அல்லது தவறான தகவல்கள் இருக்கக்கூடும் என்பதை தயவுசெய்து கவனத்தில் கொள்ளவும். அதன் தாய்மொழியில் உள்ள மூல ஆவணம் அதிகாரப்பூர்வ ஆதாரமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பைப் பயன்படுத்துவதால் ஏற்படும் எந்த தவறான புரிதல்கள் அல்லது தவறான விளக்கங்களுக்கு நாங்கள் பொறுப்பல்ல.