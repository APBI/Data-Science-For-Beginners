<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "870a0086adbc313a8eea5489bdcb2522",
  "translation_date": "2025-08-30T18:13:07+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "my"
}
-->
# ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်စပ်ဒေတာဘေ့စ်များ

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်စပ်ဒေတာဘေ့စ်များ - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

သင်ဟာ အတိတ်မှာ spreadsheet တစ်ခုကို သတင်းအချက်အလက်များကို သိမ်းဆည်းရန် အသုံးပြုဖူးတယ်ဆိုတာ များစွာဖြစ်နိုင်ပါတယ်။ သင်မှာ အတန်းများနဲ့ ကော်လံများရှိပြီး၊ အတန်းတွေမှာ သတင်းအချက်အလက် (သို့မဟုတ် ဒေတာ) ပါဝင်ပြီး၊ ကော်လံတွေကတော့ သတင်းအချက်အလက်ကို ဖော်ပြပေးပါတယ် (တခါတရံ metadata လို့ခေါ်ပါတယ်)။ ဆက်စပ်ဒေတာဘေ့စ်ဟာ ကော်လံနဲ့ အတန်းတွေပါဝင်တဲ့ ဒီအခြေခံအယူအဆပေါ်မှာ တည်ဆောက်ထားပြီး၊ သတင်းအချက်အလက်တွေကို အမျိုးမျိုးသောဇယားများတွင် ဖြန့်ဝေထားနိုင်စေပါတယ်။ ဒါကတော့ ပိုမိုရှုပ်ထွေးတဲ့ ဒေတာတွေနဲ့ အလုပ်လုပ်နိုင်စေပြီး၊ ထပ်တူထပ်မျှဖြစ်မှုကို ရှောင်ရှားနိုင်စေပြီး၊ ဒေတာကို စူးစမ်းဖော်ထုတ်ရာမှာ လွယ်ကူမှုရှိစေပါတယ်။ ဆက်စပ်ဒေတာဘေ့စ်၏ အယူအဆများကို လေ့လာကြည့်ရအောင်။

## [Pre-lecture quiz](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/8)

## အားလုံးဟာ ဇယားတွေနဲ့ စတင်တည်ဆောက်ထားပါတယ်

ဆက်စပ်ဒေတာဘေ့စ်တစ်ခုမှာ အဓိကအခြေခံအနေနဲ့ ဇယားတွေရှိပါတယ်။ spreadsheet တစ်ခုနဲ့တူသလို၊ ဇယားတစ်ခုဟာ ကော်လံနဲ့ အတန်းတွေကို စုစည်းထားတာဖြစ်ပါတယ်။ အတန်းတွေဟာ ကျွန်တော်တို့ အလုပ်လုပ်ချင်တဲ့ ဒေတာ သို့မဟုတ် သတင်းအချက်အလက်တွေကို ပါဝင်ပြီး၊ ကော်လံတွေကတော့ သူတို့ သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပါတယ်။

မြို့တော်များအကြောင်း သတင်းအချက်အလက်ကို သိမ်းဆည်းရန် ဇယားတစ်ခုကို စတင်ဖန်တီးကြည့်ရအောင်။ သူတို့ရဲ့ နာမည်နဲ့ နိုင်ငံကို စတင်သိမ်းဆည်းနိုင်ပါတယ်။ ဒါကို အောက်ပါဇယားအတိုင်း သိမ်းဆည်းနိုင်ပါတယ်-

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

**city**, **country** နဲ့ **population** ကော်လံနာမည်တွေက သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပြီး၊ အတန်းတစ်ခုစီမှာ မြို့တစ်မြို့အကြောင်း သတင်းအချက်အလက်တွေ ပါဝင်ပါတယ်။

## တစ်ခုတည်းသော ဇယားနည်းလမ်း၏ အားနည်းချက်များ

အထက်ပါဇယားဟာ သင့်အတွက် ရိုးရှင်းပြီး မျက်နှာမူဖွယ်ရှိတယ်လို့ ထင်ရနိုင်ပါတယ်။ ဒေတာဘေ့စ်ကို ပိုမိုချဲ့ထွင်ပြီး နှစ်စဉ်မိုးရွာမှု (မီလီမီတာဖြင့်) အချက်အလက်တွေကို ထည့်သွင်းကြည့်ရအောင်။ 2018, 2019, 2020 နှစ်တွေကို အာရုံစိုက်ကြည့်မယ်။ Tokyo အတွက် ထည့်သွင်းမယ်ဆိုရင် အောက်ပါအတိုင်း ဖြစ်နိုင်ပါတယ်-

| City  | Country | Year | Amount |
| ----- | ------- | ---- | ------ |
| Tokyo | Japan   | 2020 | 1690   |
| Tokyo | Japan   | 2019 | 1874   |
| Tokyo | Japan   | 2018 | 1445   |

ဒီဇယားကို ကြည့်ပြီး သတိထားမိတာရှိလား? မြို့နာမည်နဲ့ နိုင်ငံအမည်ကို ထပ်တူထပ်မျှ ထည့်သွင်းထားတာကို သတိထားမိနိုင်ပါတယ်။ ဒါဟာ သိမ်းဆည်းမှုအများကြီးယူသွားနိုင်ပြီး၊ အဓိကအားဖြင့် မလိုအပ်တဲ့ ထပ်တူဖြစ်မှုဖြစ်ပါတယ်။ Tokyo ဟာ ကျွန်တော်တို့စိတ်ဝင်စားတဲ့ နာမည်တစ်ခုသာ ရှိပါတယ်။

အိုကေ၊ တခြားနည်းလမ်းကို ကြိုးစားကြည့်ရအောင်။ နှစ်စဉ်အတွက် ကော်လံအသစ်တွေ ထည့်သွင်းကြည့်မယ်-

| City     | Country       | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Tokyo    | Japan         | 1445 | 1874 | 1690 |
| Atlanta  | United States | 1779 | 1111 | 1683 |
| Auckland | New Zealand   | 1386 | 942  | 1176 |

ဒီနည်းလမ်းက အတန်းထပ်တူဖြစ်မှုကို ရှောင်ရှားပေးနိုင်ပေမယ့် အခြားပြဿနာတွေကို ဖြစ်စေပါတယ်။ နှစ်အသစ်တစ်ခုရောက်တိုင်း ဇယားဖွဲ့စည်းမှုကို ပြင်ဆင်ဖို့ လိုအပ်လာနိုင်ပါတယ်။ ထို့အပြင် ဒေတာတွေ တိုးလာတာနဲ့အမျှ နှစ်တွေကို ကော်လံအဖြစ်ထားတာက ဒေတာကို ရှာဖွေခြင်းနဲ့ တွက်ချက်ရာမှာ ပိုမိုခက်ခဲစေပါတယ်။

ဒါကြောင့် ဇယားများစွာနဲ့ ဆက်စပ်မှုတွေ လိုအပ်ပါတယ်။ ဒေတာကို ခွဲထုတ်ထားခြင်းဖြင့် ထပ်တူဖြစ်မှုကို ရှောင်ရှားနိုင်ပြီး၊ ဒေတာနဲ့ အလုပ်လုပ်ရာမှာ ပိုမိုလွယ်ကူမှု ရရှိနိုင်ပါတယ်။

## ဆက်စပ်မှု၏ အယူအဆများ

ကျွန်တော်တို့ရဲ့ ဒေတာကို ပြန်လည်ကြည့်ပြီး ဘယ်လိုခွဲထုတ်မလဲ ဆုံးဖြတ်ကြည့်ရအောင်။ မြို့နာမည်နဲ့ နိုင်ငံအမည်ကို သိမ်းဆည်းချင်တာကို သိပြီးသားဖြစ်ပါတယ်၊ ဒါကြောင့် ဒါကို ဇယားတစ်ခုမှာ သိမ်းဆည်းရမယ်လို့ ထင်ရပါတယ်။

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

ဒါပေမယ့် နောက်ထပ်ဇယားကို ဖန်တီးမတိုင်မီ၊ မြို့တစ်မြို့ကို ဘယ်လိုကိုးကားမလဲ ဆုံးဖြတ်ဖို့ လိုအပ်ပါတယ်။ တစ်ခုတည်းသော အတန်းကို သတ်မှတ်ဖော်ပြဖို့ ID သို့မဟုတ် (နည်းပညာဆိုင်ရာဒေတာဘေ့စ်အရ) primary key တစ်ခုလိုအပ်ပါတယ်။ Primary key ဟာ ဇယားတစ်ခုမှာ အတန်းတစ်ခုစီကို သီးခြားသတ်မှတ်ဖော်ပြဖို့ အသုံးပြုတဲ့ တန်ဖိုးတစ်ခုဖြစ်ပါတယ်။ ဒါဟာ နာမည်လိုက်မူတည်နိုင်ပေမယ့် (ဥပမာ မြို့နာမည်ကို အသုံးပြုနိုင်ပါတယ်)၊ အမြဲတမ်းနံပါတ် သို့မဟုတ် အခြား ID တစ်ခုဖြစ်သင့်ပါတယ်။ ID ဟာ ဘယ်တော့မှ မပြောင်းလဲသင့်ပါဘူး၊ ပြောင်းလဲမယ်ဆိုရင် ဆက်စပ်မှုကို ပျက်စီးစေမှာဖြစ်ပါတယ်။ အများအားဖြင့် primary key သို့မဟုတ် ID ဟာ အလိုအလျောက်ဖန်တီးတဲ့ နံပါတ်ဖြစ်လေ့ရှိပါတယ်။

> ✅ Primary key ကို အတိုကောက် PK လို့ ခေါ်လေ့ရှိပါတယ်။

### cities

| city_id | City     | Country       |
| ------- | -------- | ------------- |
| 1       | Tokyo    | Japan         |
| 2       | Atlanta  | United States |
| 3       | Auckland | New Zealand   |

> ✅ ဒီသင်ခန်းစာအတွင်း "id" နဲ့ "primary key" ဆိုတဲ့ စကားလုံးတွေကို အပြောင်းအလဲအသုံးပြုတာကို သတိထားမိပါလိမ့်မယ်။ ဒီအယူအဆတွေဟာ DataFrames တွေမှာလည်း သက်ဆိုင်ပါတယ်၊ ဒါပေမယ့် DataFrames တွေမှာ "primary key" ဆိုတဲ့ စကားလုံးကို အသုံးမပြုပါဘူး၊ သို့သော် သူတို့ဟာ အလားတူပုံစံနဲ့ အလုပ်လုပ်တယ်ဆိုတာ သတိထားမိပါလိမ့်မယ်။

မြို့တော်ဇယားကို ဖန်တီးပြီးပါက၊ မိုးရွာမှုကို သိမ်းဆည်းကြည့်ရအောင်။ မြို့အကြောင်း အပြည့်အစုံကို ထပ်တူထည့်သွင်းမယ့်အစား ID ကို အသုံးပြုနိုင်ပါတယ်။ အသစ်ဖန်တီးတဲ့ ဇယားမှာလည်း *id* ကော်လံတစ်ခု ထည့်သွင်းထားသင့်ပါတယ်၊ ဇယားတိုင်းမှာ id သို့မဟုတ် primary key တစ်ခုရှိသင့်ပါတယ်။

### rainfall

| rainfall_id | city_id | Year | Amount |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

အသစ်ဖန်တီးထားတဲ့ **rainfall** ဇယားထဲမှာ **city_id** ကော်လံကို သတိထားမိပါလိမ့်မယ်။ ဒီကော်လံဟာ **cities** ဇယားထဲက ID တွေကို ကိုးကားထားတဲ့ တန်ဖိုးတွေ ပါဝင်ပါတယ်။ နည်းပညာဆိုင်ရာ ဆက်စပ်ဒေတာအရ ဒီကို **foreign key** လို့ ခေါ်ပါတယ်၊ ဒါဟာ တခြားဇယားက primary key တစ်ခုဖြစ်ပါတယ်။ ဒါကို ကိုးကားချက် သို့မဟုတ် pointer တစ်ခုအနေနဲ့ ထင်မြင်နိုင်ပါတယ်။ **city_id** 1 ဟာ Tokyo ကို ကိုးကားထားပါတယ်။

> [!NOTE] Foreign key ကို အတိုကောက် FK လို့ ခေါ်လေ့ရှိပါတယ်။

## ဒေတာကို ရှာဖွေခြင်း

ဒေတာကို ဇယားနှစ်ခုခွဲထားပြီးနောက်၊ ဒေတာကို ဘယ်လိုရှာဖွေမလဲဆိုတာ စဉ်းစားနိုင်ပါတယ်။ MySQL, SQL Server, Oracle တို့လို ဆက်စပ်ဒေတာဘေ့စ်ကို အသုံးပြုမယ်ဆိုရင် Structured Query Language (SQL) လို့ခေါ်တဲ့ ဘာသာစကားတစ်ခုကို အသုံးပြုနိုင်ပါတယ်။ SQL (တခါတရံ sequel လို့လည်း အသံထွက်) ဟာ ဆက်စပ်ဒေတာဘေ့စ်ထဲက ဒေတာကို ရှာဖွေခြင်းနဲ့ ပြင်ဆင်ခြင်းအတွက် အသုံးပြုတဲ့ စံဘာသာစကားတစ်ခုဖြစ်ပါတယ်။

ဒေတာကို ရှာဖွေဖို့ `SELECT` ဆိုတဲ့ command ကို အသုံးပြုပါတယ်။ အဓိကအားဖြင့် သင် **ကြည့်ချင်တဲ့ ကော်လံတွေကို** **သင့်ဇယားထဲကနေ** ရွေးချယ်ပါတယ်။ မြို့နာမည်တွေကိုသာ ပြသချင်တယ်ဆိုရင် အောက်ပါအတိုင်း ရေးနိုင်ပါတယ်-

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ဟာ သင်ကြည့်ချင်တဲ့ ကော်လံတွေကို ရေးတဲ့နေရာဖြစ်ပြီး၊ `FROM` ဟာ သူတို့ပါဝင်တဲ့ ဇယားကို ရေးတဲ့နေရာဖြစ်ပါတယ်။

> [NOTE] SQL syntax ဟာ case-insensitive ဖြစ်ပါတယ်၊ `select` နဲ့ `SELECT` ဟာ တူညီတဲ့အဓိပ္ပါယ်ရှိပါတယ်။ သို့သော် သင်အသုံးပြုတဲ့ ဒေတာဘေ့စ်အမျိုးအစားပေါ်မူတည်ပြီး ကော်လံနဲ့ ဇယားတွေက case-sensitive ဖြစ်နိုင်ပါတယ်။ ဒါကြောင့် programming မှာ အရာအားလုံးကို case-sensitive ဖြစ်တယ်လို့ သတ်မှတ်ပြီး အမြဲတမ်းလုပ်ဆောင်သင့်ပါတယ်။ SQL query တွေကို ရေးတဲ့အခါ keyword တွေကို အမြဲ uppercase နဲ့ရေးတာဟာ သုံးစွဲမှုအလေ့အကျင့်ဖြစ်ပါတယ်။

အထက်ပါ query ဟာ မြို့အားလုံးကို ပြသပေးပါလိမ့်မယ်။ အကယ်၍ New Zealand မှာရှိတဲ့ မြို့တွေကိုသာ ပြသချင်တယ်ဆိုရင် filter တစ်ခုလိုအပ်ပါတယ်။ SQL keyword ကတော့ `WHERE` ဖြစ်ပြီး၊ "တစ်ခုခုမှန်ကန်တဲ့နေရာ" လို့ အဓိပ္ပါယ်ရပါတယ်။

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## ဒေတာတွေကို ပေါင်းစည်းခြင်း

အခုထိ ကျွန်တော်တို့ ဇယားတစ်ခုထဲက ဒေတာကိုသာ ရှာဖွေခဲ့ပါတယ်။ အခုတော့ **cities** နဲ့ **rainfall** ဇယားနှစ်ခုက ဒေတာတွေကို ပေါင်းစည်းချင်ပါတယ်။ ဒါကို *joining* လို့ခေါ်ပါတယ်။ သင် effectively ဇယားနှစ်ခုကြားမှာ ချိတ်ဆက်မှုတစ်ခု ဖန်တီးပြီး၊ ဇယားတစ်ခုစီက ကော်လံတစ်ခုစီရဲ့ တန်ဖိုးတွေကို ကိုက်ညီစေမှာဖြစ်ပါတယ်။

ကျွန်တော်တို့ရဲ့ ဥပမာမှာ **rainfall** ဇယားထဲက **city_id** ကော်လံနဲ့ **cities** ဇယားထဲက **city_id** ကော်လံကို ကိုက်ညီစေမှာဖြစ်ပါတယ်။ ဒါဟာ မိုးရွာမှုတန်ဖိုးကို သူ့ရဲ့ သက်ဆိုင်ရာ မြို့နဲ့ ကိုက်ညီစေမှာဖြစ်ပါတယ်။ ကျွန်တော်တို့လုပ်မယ့် join အမျိုးအစားက *inner* join လို့ခေါ်ပြီး၊ ဇယားတစ်ခုက အတန်းတစ်ခုစီဟာ တစ်ခုခုနဲ့ ကိုက်ညီမယ်ဆိုမှသာ ပြသပေးမှာဖြစ်ပါတယ်။ ကျွန်တော်တို့ရဲ့ ဥပမာမှာ မြို့တိုင်းမှာ မိုးရွာမှုရှိတာကြောင့် အားလုံးကို ပြသပေးမှာဖြစ်ပါတယ်။

ကျွန်တော်တို့ရဲ့ မြို့အားလုံးအတွက် 2019 ခုနှစ် မိုးရွာမှုကို ရှာဖွေကြည့်ရအောင်။

ဒီကို အဆင့်လိုက်လုပ်ဆောင်ပါမယ်။ ပထမအဆင့်ကတော့ **city_id** ကော်လံကို ကိုက်ညီစေပြီး ဇယားတွေကို ပေါင်းစည်းဖို့ ဖြစ်ပါတယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

ကျွန်တော်တို့ highlight လုပ်ထားတဲ့ ကော်လံနှစ်ခုနဲ့ ဇယားတွေကို **city_id** ကော်လံဖြင့် ပေါင်းစည်းချင်တယ်ဆိုတာကို ဖော်ပြထားပါတယ်။ အခုတော့ `WHERE` statement ကို ထည့်သွင်းပြီး 2019 ခုနှစ်ကိုသာ filter လုပ်ကြည့်ရအောင်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## အနှိပ်ချုပ်

ဆက်စပ်ဒေတာဘေ့စ်တွေဟာ သတင်းအချက်အလက်တွေကို ဇယားများစွာအကြား ခွဲထုတ်ထားပြီး၊ ပြန်လည်ဖော်ပြခြင်းနဲ့ ချိန်ညှိမှုအတွက် ပြန်လည်ပေါင်းစည်းထားတာဖြစ်ပါတယ်။ ဒါဟာ တွက်ချက်မှုတွေကို ပြုလုပ်ခြင်းနဲ့ ဒေတာကို ပြောင်းလဲခြင်းအတွက် အလွန်လွယ်ကူမှုရှိစေပါတယ်။ သင်ဟာ ဆက်စပ်ဒေတာဘေ့စ်ရဲ့ အဓိကအယူအဆတွေကို မြင်တွေ့ပြီး၊ ဇယားနှစ်ခုကြား join ပြုလုပ်ပုံကိုလည်း လေ့လာခဲ့ပါပြီ။

## 🚀 စိန်ခေါ်မှု

အင်တာနက်ပေါ်မှာ ဆက်စပ်ဒေတာဘေ့စ်အမျိုးမျိုး ရှိပါတယ်။ သင်လေ့လာခဲ့တဲ့ ကျွမ်းကျင်မှုတွေကို အသုံးပြုပြီး ဒေတာကို စူးစမ်းကြည့်နိုင်ပါတယ်။

## Post

---

**ဝက်ဘ်ဆိုက်မှတ်ချက်**:  
ဤစာရွက်စာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ကို အသုံးပြု၍ ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှန်ကန်မှုအတွက် ကြိုးစားနေသော်လည်း၊ အလိုအလျောက်ဘာသာပြန်ခြင်းတွင် အမှားများ သို့မဟုတ် မမှန်ကန်မှုများ ပါဝင်နိုင်ကြောင်း သတိပြုပါ။ မူလဘာသာစကားဖြင့် ရေးသားထားသော စာရွက်စာတမ်းကို အာဏာတည်သော ရင်းမြစ်အဖြစ် သတ်မှတ်သင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်များကို အသုံးပြုရန် အကြံပြုပါသည်။ ဤဘာသာပြန်ကို အသုံးပြုခြင်းမှ ဖြစ်ပေါ်လာသော နားလည်မှုမှားခြင်း သို့မဟုတ် အဓိပ္ပါယ်မှားခြင်းများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။