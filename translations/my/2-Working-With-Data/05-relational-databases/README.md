<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "11b166fbcb7eaf82308cdc24b562f687",
  "translation_date": "2025-09-05T05:14:04+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "my"
}
-->
# ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

သင်ဟာ အတိတ်ကာလမှာ အချက်အလက်တွေကို သိမ်းဆည်းဖို့ spreadsheet တစ်ခုကို အသုံးပြုဖူးနိုင်ပါတယ်။ သင်မှာ အတန်းတွေ (rows) နဲ့ ကော်လံတွေ (columns) ရှိပြီး အတန်းတွေမှာ အချက်အလက် (သို့မဟုတ် ဒေတာ) တွေ ပါဝင်ပြီး ကော်လံတွေက အချက်အလက်ကို ဖော်ပြပေးပါတယ် (တစ်ခါတစ်ရံ metadata လို့ခေါ်ပါတယ်)။ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်ဟာ ကော်လံနဲ့ အတန်းတွေကို အခြေခံပြီး တစ်ခုပေါင်းစပ်ထားတဲ့ အချက်အလက်တွေကို များစွာသော အတန်းများတွင် ဖြန့်ဝေထားနိုင်ပါတယ်။ ဒါဟာ ပိုမိုရှုပ်ထွေးတဲ့ ဒေတာတွေနဲ့ အလုပ်လုပ်နိုင်စေပြီး အချက်အလက်များကို ထပ်တူထပ်မျှ မဖြစ်စေဘဲ ပိုမိုလွယ်ကူစွာ ရှာဖွေနိုင်စေပါတယ်။ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်၏ အယူအဆများကို လေ့လာကြမယ်။

## [Pre-lecture quiz](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/8)

## အားလုံးဟာ အတန်းတွေကနေ စတင်ပါတယ်

ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်ဟာ အခြေခံအနေဖြင့် အတန်းတွေကို အခြေခံထားပါတယ်။ spreadsheet တစ်ခုနဲ့ တူတူပဲ အတန်းဟာ ကော်လံနဲ့ အတန်းတွေကို စုပေါင်းထားတဲ့ collection တစ်ခုဖြစ်ပါတယ်။ အတန်းတွေဟာ သင်လုပ်ဆောင်လိုတဲ့ ဒေတာ (ဥပမာ မြို့နာမည် သို့မဟုတ် မိုးရွာသွန်းမှု) ကို ပါဝင်ပြီး ကော်လံတွေက ဒေတာကို ဖော်ပြပေးပါတယ်။

မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို သိမ်းဆည်းဖို့ အတန်းတစ်ခုကို စတင်ဖန်တီးကြမယ်။ ဒါကို အောက်ပါအတိုင်း သိမ်းဆည်းနိုင်ပါတယ်။

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

**city**, **country** နဲ့ **population** ကော်လံနာမည်တွေဟာ သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပြီး အတန်းတစ်ခုစီမှာ မြို့တစ်မြို့အကြောင်းအချက်အလက်တွေ ပါဝင်ပါတယ်။

## တစ်ခုတည်းသော အတန်းနည်းလမ်း၏ အားနည်းချက်များ

အထက်ပါ အတန်းဟာ သင့်အတွက် ရိုးရှင်းပြီး ရင်းနှီးနေတဲ့ ပုံစံတစ်ခုဖြစ်နိုင်ပါတယ်။ ဒေတာဘေ့စ်ကို ပိုမိုချဲ့ထွင်ဖို့ ၂၀၁၈၊ ၂၀၁၉ နဲ့ ၂၀၂၀ နှစ်များအတွက် နှစ်စဉ် မိုးရွာသွန်းမှု (မီလီမီတာ) အချက်အလက်တွေကို ထည့်သွင်းကြမယ်။ Tokyo အတွက် ထည့်သွင်းမယ်ဆိုရင် အောက်ပါအတိုင်း ဖြစ်နိုင်ပါတယ်။

| City  | Country | Year | Amount |
| ----- | ------- | ---- | ------ |
| Tokyo | Japan   | 2020 | 1690   |
| Tokyo | Japan   | 2019 | 1874   |
| Tokyo | Japan   | 2018 | 1445   |

ဒီအတန်းကို ကြည့်ပြီး သင်ဘာတွေ သတိထားမိပါသလဲ? မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို ထပ်တူထပ်မျှ ထပ်နေပါတယ်။ ဒါဟာ သိမ်းဆည်းမှုအများကြီးကို အသုံးပြုနိုင်ပြီး မလိုအပ်တဲ့ အချက်အလက်တွေကို ထပ်နေပါတယ်။ Tokyo ဟာ တစ်ခုတည်းသော နာမည်ရှိပါတယ်။

အခြားနည်းလမ်းကို စမ်းကြည့်ရအောင်။ နှစ်စဉ်အချက်အလက်တွေကို ကော်လံအသစ်တွေ အဖြစ် ထည့်သွင်းကြမယ်။

| City     | Country       | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Tokyo    | Japan         | 1445 | 1874 | 1690 |
| Atlanta  | United States | 1779 | 1111 | 1683 |
| Auckland | New Zealand   | 1386 | 942  | 1176 |

ဒီနည်းလမ်းဟာ အတန်းထပ်နေမှုကို ရှောင်ရှားပေမယ့် အခြားပြဿနာတွေကို ဖြစ်စေနိုင်ပါတယ်။ နှစ်အသစ်တစ်ခုရလာတိုင်း အတန်းပုံစံကို ပြောင်းလဲဖို့ လိုအပ်ပါတယ်။ ဒေတာများစွာ ရှိလာတဲ့အခါ နှစ်တွေကို ကော်လံအဖြစ်ထားရင် အချက်အလက်တွေကို ရှာဖွေခြင်းနဲ့ တွက်ချက်ခြင်းမှာ အခက်အခဲဖြစ်နိုင်ပါတယ်။

ဒါကြောင့် အတန်းများစွာနဲ့ ဆက်နွယ်မှုတွေ လိုအပ်ပါတယ်။ ဒေတာကို ခွဲခြားထားခြင်းက ထပ်နေမှုကို ရှောင်ရှားပြီး ဒေတာနဲ့ အလုပ်လုပ်တဲ့ နည်းလမ်းတွေမှာ ပိုမိုလွယ်ကူစေပါတယ်။

## ဆက်နွယ်မှု၏ အယူအဆများ

ဒေတာကို ပြန်လည်သုံးသပ်ပြီး ဘယ်လို ခွဲခြားထားမလဲ ဆုံးဖြတ်ကြမယ်။ မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို သိမ်းဆည်းဖို့ တစ်ခုတည်းသော အတန်းမှာ အကောင်းဆုံးဖြစ်နိုင်ပါတယ်။

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

ဒါပေမယ့် နောက်ထပ်အတန်းကို ဖန်တီးမတိုင်မီ မြို့တစ်မြို့ကို ရည်ညွှန်းဖို့ နည်းလမ်းတစ်ခုလိုအပ်ပါတယ်။ ID သို့မဟုတ် (နည်းပညာဆိုင်ရာ ဒေတာဘေ့စ်အရ) primary key တစ်ခုလိုအပ်ပါတယ်။ primary key ဟာ အတန်းတစ်ခုစီကို သတ်မှတ်ဖို့ အသုံးပြုတဲ့ တန်ဖိုးတစ်ခုဖြစ်ပါတယ်။ ဒါဟာ တန်ဖိုးကို အခြေခံထားပြီး (ဥပမာ မြို့နာမည်ကို အသုံးပြုနိုင်ပါတယ်) ဖြစ်နိုင်ပေမယ့် အမြဲတမ်း နံပါတ် သို့မဟုတ် အခြား ID ဖြစ်သင့်ပါတယ်။ ID ဟာ ဘယ်တော့မှ မပြောင်းလဲသင့်ပါဘူး၊ ပြောင်းလဲရင် ဆက်နွယ်မှုကို ပျက်စီးစေနိုင်ပါတယ်။ အများအားဖြင့် primary key သို့မဟုတ် ID ဟာ auto-generated နံပါတ်ဖြစ်လေ့ရှိပါတယ်။

> ✅ Primary key ကို အတိုကောက် PK လို့ ခေါ်လေ့ရှိပါတယ်

### cities

| city_id | City     | Country       |
| ------- | -------- | ------------- |
| 1       | Tokyo    | Japan         |
| 2       | Atlanta  | United States |
| 3       | Auckland | New Zealand   |

> ✅ ဒီသင်ခန်းစာအတွင်း "id" နဲ့ "primary key" ဆိုတဲ့ စကားလုံးတွေကို အလှည့်ကျ အသုံးပြုတာကို သတိထားမိပါလိမ့်မယ်။ ဒီအယူအဆတွေဟာ DataFrames တွေမှာလည်း သက်ဆိုင်ပါတယ်၊ သင်နောက်ပိုင်းမှာ DataFrames တွေကို လေ့လာပါမယ်။ DataFrames တွေမှာ "primary key" ဆိုတဲ့ စကားလုံးကို မသုံးပေမယ့် အတူတူသော လုပ်ဆောင်မှုကို ပြုလုပ်ပါတယ်။

မြို့အတန်းကို ဖန်တီးပြီးရင် မိုးရွာသွန်းမှုကို သိမ်းဆည်းကြမယ်။ မြို့အချက်အလက်ကို ထပ်နေခြင်းမရှိဘဲ ID ကို အသုံးပြုနိုင်ပါတယ်။ အသစ်ဖန်တီးထားတဲ့ အတန်းမှာ *id* ကော်လံကို ထည့်သွင်းသင့်ပါတယ်၊ အတန်းအားလုံးမှာ ID သို့မဟုတ် primary key ရှိသင့်ပါတယ်။

### rainfall

| rainfall_id | city_id | Year | Amount |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

အသစ်ဖန်တီးထားတဲ့ **rainfall** အတန်းထဲမှာ **city_id** ကော်လံကို သတိထားမိပါလိမ့်မယ်။ ဒီကော်လံဟာ **cities** အတန်းထဲက ID တွေကို ရည်ညွှန်းတဲ့ တန်ဖိုးတွေကို ပါဝင်ပါတယ်။ နည်းပညာဆိုင်ရာ ဆက်နွယ်မှုရှိသော ဒေတာအရ ဒီကို **foreign key** လို့ခေါ်ပါတယ်၊ ဒါဟာ အခြားအတန်းက primary key ဖြစ်ပါတယ်။ သင်ဟာ ဒီကို ရည်ညွှန်းချက် သို့မဟုတ် pointer အဖြစ် သက်ဆိုင်စဉ်းစားနိုင်ပါတယ်။ **city_id** 1 ဟာ Tokyo ကို ရည်ညွှန်းပါတယ်။

> [!NOTE] Foreign key ကို အတိုကောက် FK လို့ ခေါ်လေ့ရှိပါတယ်

## ဒေတာကို ရှာဖွေခြင်း

ဒေတာကို အတန်းနှစ်ခုခွဲထားပြီး သင်ဟာ ဒေတာကို ဘယ်လို ရှာဖွေမလဲ စဉ်းစားနိုင်ပါတယ်။ MySQL, SQL Server သို့မဟုတ် Oracle ကဲ့သို့သော ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်ကို အသုံးပြုမယ်ဆိုရင် Structured Query Language (SQL) ဆိုတဲ့ ဘာသာစကားကို အသုံးပြုနိုင်ပါတယ်။ SQL (တစ်ခါတစ်ရံ sequel လို့လည်း အသံထွက်) ဟာ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်ထဲမှာ ဒေတာကို ရှာဖွေခြင်းနဲ့ ပြင်ဆင်ခြင်းအတွက် အသုံးပြုတဲ့ စံဘာသာစကားဖြစ်ပါတယ်။

ဒေတာကို ရှာဖွေဖို့ `SELECT` command ကို အသုံးပြုပါတယ်။ အခြေခံအနေဖြင့် သင် **select** လုပ်လိုတဲ့ ကော်လံတွေကို **from** ဆိုတဲ့ အတန်းထဲကနေ ရွေးချယ်ပါတယ်။ မြို့နာမည်တွေကိုသာ ပြသလိုရင် အောက်ပါအတိုင်း ရေးနိုင်ပါတယ်။

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ဟာ သင်ကြည့်လိုတဲ့ ကော်လံတွေကို ရေးတဲ့နေရာဖြစ်ပြီး `FROM` ဟာ အတန်းနာမည်ကို ရေးတဲ့နေရာဖြစ်ပါတယ်။

> [NOTE] SQL syntax ဟာ case-insensitive ဖြစ်ပြီး `select` နဲ့ `SELECT` ဟာ တူတူပဲ ဖြစ်ပါတယ်။ ဒါပေမယ့် သင်အသုံးပြုတဲ့ ဒေတာဘေ့စ်အမျိုးအစားပေါ်မူတည်ပြီး ကော်လံနဲ့ အတန်းနာမည်တွေ case-sensitive ဖြစ်နိုင်ပါတယ်။ အဲ့ဒီအတွက် programming မှာ အားလုံးကို case-sensitive ဖြစ်တယ်လို့ သက်ဆိုင်စဉ်းစားပြီး ရေးသားသင့်ပါတယ်။ SQL queries ရေးတဲ့အခါ keyword တွေကို အမြဲတမ်း uppercase လိုက်နာရေးသားသင့်ပါတယ်။

အထက်ပါ query ဟာ မြို့အားလုံးကို ပြသပါမယ်။ အခု New Zealand မှာရှိတဲ့ မြို့တွေကိုသာ ပြသချင်တယ်ဆိုရင် filter တစ်ခုလိုအပ်ပါတယ်။ SQL keyword ဟာ `WHERE` ဖြစ်ပြီး "အဲ့ဒီအချက်အလက်မှန်တဲ့နေရာမှာ" ဆိုတဲ့ အဓိပ္ပါယ်ပါပါတယ်။

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## ဒေတာကို ပေါင်းစည်းခြင်း

အခုအထိ သင်ဟာ တစ်ခုတည်းသော အတန်းကနေ ဒေတာကို ရှာဖွေခဲ့ပါတယ်။ အခု **cities** နဲ့ **rainfall** အတန်းတွေကနေ ဒေတာကို ပေါင်းစည်းချင်ပါတယ်။ ဒါကို *joining* လို့ခေါ်ပါတယ်။ သင် effectively အတန်းနှစ်ခုအကြား seam တစ်ခုဖန်တီးပြီး အတန်းတစ်ခုစီက ကော်လံတွေကို တွဲဖက်ပေးပါမယ်။

ဥပမာအနေနဲ့ **rainfall** ထဲက **city_id** ကော်လံကို **cities** ထဲက **city_id** ကော်လံနဲ့ တွဲဖက်ပါမယ်။ ဒါဟာ မိုးရွာသွန်းမှုတန်ဖိုးကို သက်ဆိုင်ရာ မြို့နဲ့ တွဲဖက်ပေးပါမယ်။ join လုပ်တဲ့အမျိုးအစားဟာ *inner* join ဖြစ်ပြီး အတန်းတွေက တစ်ခုနဲ့ တစ်ခု မကိုက်ညီရင် ပြသမည်မဟုတ်ပါဘူး။ ကျွန်တော်တို့ရဲ့ ဥပမာမှာ မြို့အားလုံးမှာ မိုးရွာသွန်းမှုရှိပါတယ်၊ ဒါကြောင့် အားလုံးကို ပြသပါမယ်။

အခု ၂၀၁၉ ခုနှစ်အတွက် မြို့အားလုံးရဲ့ မိုးရွာသွန်းမှုကို ရှာဖွေကြမယ်။

ဒီကို အဆင့်ဆင့်လုပ်ဆောင်ပါမယ်။ ပထမအဆင့်မှာ **city_id** ကော်လံကို seam အဖြစ် သတ်မှတ်ပြီး ဒေတာကို ပေါင်းစည်းပါမယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

အတန်းနှစ်ခုကို join လုပ်ပြီး **city_id** ကော်လံကို သတ်မှတ်ထားပါတယ်။ အခု `WHERE` statement ကို ထည့်သွင်းပြီး ၂၀၁၉ ခုနှစ်ကိုသာ filter လုပ်ပါမယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## အကျဉ်းချုပ်

ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်တွေဟာ အချက်အလက်တွေကို အတန်းများစွာခွဲခြားထားပြီး ပြန်လည်ဖော်ပြခြင်းနဲ့ ခန့်မှန်းခြင်းအတွက် ပြန်လည်ပေါင်းစည်းထားပါတယ်။ ဒါဟာ ဒေတာကို တွက်ချက်ခြင်းနဲ့ ပြုပြင်ခြင်းအတွက် ပိုမိုလွယ်ကူစေပါတယ်။ သင်ဟာ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်၏ အခြေခံအယူအဆတွေကို မြင်တွေ့ပြီး အတန်းနှစ်ခုအကြား join လုပ်ပုံကို လေ့လာခဲ့ပါတယ်။

## 🚀 စိန်ခေါ်မှု

အင်တာနက်ပေါ်မှာ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များစွာ ရှိပါတယ်။ သင်လေ့လာထားတဲ့ ကျွမ်းကျင်မှုတွေကို အသုံးပြုပြီး ဒေတာကို ရှာဖွေကြည့်နိုင်ပါတယ်။

## Post-Lecture Quiz

## [Post-lecture quiz](https://ff-quizzes.netlify.app/en/ds/)

## ပြန်လည်သုံးသပ်ခြင်းနှင့် ကိုယ်တိုင်လေ့လာခြင်း

SQL နဲ့ ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်အယူအဆတွေကို ဆက်လက်လေ့လာဖို့ [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) မှာ အရင်းအမြစ်များစွာ ရရှိနိုင်ပါတယ်။

- [Describe concepts of relational data](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Get Started Querying with Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL ဟာ SQL ရဲ့ version တစ်ခုဖြစ်ပါတယ်)
- [SQL content on Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## လုပ်ငန်းတာဝန်

[Assignment Title](assignment

---

**အကြောင်းကြားချက်**:  
ဤစာရွက်စာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ကို အသုံးပြု၍ ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှုအတွက် ကြိုးစားနေသော်လည်း၊ အလိုအလျောက် ဘာသာပြန်မှုများတွင် အမှားများ သို့မဟုတ် မတိကျမှုများ ပါဝင်နိုင်သည်ကို သတိပြုပါ။ မူရင်းဘာသာစကားဖြင့် ရေးသားထားသော စာရွက်စာတမ်းကို အာဏာတရ အရင်းအမြစ်အဖြစ် ရှုလေ့လာသင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်များမှ ပရော်ဖက်ရှင်နယ် ဘာသာပြန်မှုကို အကြံပြုပါသည်။ ဤဘာသာပြန်မှုကို အသုံးပြုခြင်းမှ ဖြစ်ပေါ်လာသော အလွဲအလွတ်များ သို့မဟုတ် အနားယူမှုများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။