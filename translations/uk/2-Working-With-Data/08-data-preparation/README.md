<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "3ade580a06b5f04d57cc83a768a8fb77",
  "translation_date": "2025-08-30T18:18:02+00:00",
  "source_file": "2-Working-With-Data/08-data-preparation/README.md",
  "language_code": "uk"
}
-->
# Робота з даними: Підготовка даних

|![ Скетчноут від [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/08-DataPreparation.png)|
|:---:|
|Підготовка даних - _Скетчноут від [@nitya](https://twitter.com/nitya)_ |

## [Тест перед лекцією](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/14)

Залежно від джерела, необроблені дані можуть містити певні невідповідності, які створюють труднощі для аналізу та моделювання. Іншими словами, ці дані можна класифікувати як "брудні", і їх потрібно очистити. У цьому уроці розглядаються техніки очищення та трансформації даних для вирішення проблем із відсутніми, неточними або неповними даними. Теми, які розглядаються в цьому уроці, використовують Python і бібліотеку Pandas і будуть [демонструватися у зошиті](notebook.ipynb) у цій директорії.

## Важливість очищення даних

- **Зручність використання та повторного використання**: Коли дані правильно організовані та нормалізовані, їх легше шукати, використовувати та ділитися з іншими.

- **Послідовність**: У науці про дані часто доводиться працювати з кількома наборами даних, які потрібно об’єднувати. Забезпечення спільної стандартизації кожного окремого набору даних гарантує, що дані залишатимуться корисними після їх об’єднання в один набір.

- **Точність моделі**: Очищені дані підвищують точність моделей, які на них базуються.

## Поширені цілі та стратегії очищення

- **Дослідження набору даних**: Дослідження даних, яке розглядається в [наступному уроці](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/4-Data-Science-Lifecycle/15-analyzing), допомагає виявити дані, які потрібно очистити. Візуальне спостереження за значеннями в наборі даних може встановити очікування щодо того, як виглядатиме решта, або дати уявлення про проблеми, які можна вирішити. Дослідження може включати базові запити, візуалізації та вибірки.

- **Форматування**: Залежно від джерела, дані можуть мати невідповідності у представленні. Це може спричинити проблеми з пошуком і відображенням значень, коли вони є в наборі даних, але неправильно представлені у візуалізаціях або результатах запитів. Поширені проблеми форматування включають усунення пробілів, дат і типів даних. Вирішення питань форматування зазвичай залежить від користувачів даних. Наприклад, стандарти представлення дат і чисел можуть відрізнятися залежно від країни.

- **Дублювання**: Дані, які мають більше одного входження, можуть спричиняти неточні результати й зазвичай мають бути видалені. Це часто трапляється під час об’єднання двох або більше наборів даних. Однак бувають випадки, коли дублювання в об’єднаних наборах даних містить частини, які можуть надати додаткову інформацію, і їх потрібно зберегти.

- **Відсутні дані**: Відсутні дані можуть спричиняти неточності, а також слабкі або упереджені результати. Іноді це можна вирішити шляхом "перезавантаження" даних, заповнення відсутніх значень за допомогою обчислень і коду, наприклад Python, або просто видалення значення та відповідних даних. Причини відсутності даних можуть бути різними, і дії, які вживаються для вирішення цієї проблеми, залежать від того, як і чому дані зникли.

## Дослідження інформації про DataFrame
> **Ціль навчання:** До кінця цього підрозділу ви повинні впевнено знаходити загальну інформацію про дані, що зберігаються в pandas DataFrame.

Після завантаження даних у pandas вони, швидше за все, будуть у вигляді DataFrame (зверніться до попереднього [уроку](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/2-Working-With-Data/07-python#dataframe) для детального огляду). Але якщо набір даних у вашому DataFrame має 60 000 рядків і 400 стовпців, як почати розуміти, з чим ви працюєте? На щастя, [pandas](https://pandas.pydata.org/) надає зручні інструменти для швидкого перегляду загальної інформації про DataFrame, а також перших і останніх кількох рядків.

Щоб дослідити цю функціональність, ми імпортуємо бібліотеку Python scikit-learn і використаємо знаковий набір даних: **Iris data set**.

```python
import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris()
iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])
```
|                                        |sepal length (cm)|sepal width (cm)|petal length (cm)|petal width (cm)|
|----------------------------------------|-----------------|----------------|-----------------|----------------|
|0                                       |5.1              |3.5             |1.4              |0.2             |
|1                                       |4.9              |3.0             |1.4              |0.2             |
|2                                       |4.7              |3.2             |1.3              |0.2             |
|3                                       |4.6              |3.1             |1.5              |0.2             |
|4                                       |5.0              |3.6             |1.4              |0.2             |

- **DataFrame.info**: Для початку метод `info()` використовується для виведення зведення про вміст, що міститься в `DataFrame`. Давайте подивимося на цей набір даних:
```python
iris_df.info()
```
```
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   sepal length (cm)  150 non-null    float64
 1   sepal width (cm)   150 non-null    float64
 2   petal length (cm)  150 non-null    float64
 3   petal width (cm)   150 non-null    float64
dtypes: float64(4)
memory usage: 4.8 KB
```
З цього ми знаємо, що набір даних *Iris* має 150 записів у чотирьох стовпцях без відсутніх значень. Усі дані зберігаються як 64-бітні числа з плаваючою комою.

- **DataFrame.head()**: Далі, щоб перевірити фактичний вміст `DataFrame`, ми використовуємо метод `head()`. Давайте подивимося, як виглядають перші кілька рядків нашого `iris_df`:
```python
iris_df.head()
```
```
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0                5.1               3.5                1.4               0.2
1                4.9               3.0                1.4               0.2
2                4.7               3.2                1.3               0.2
3                4.6               3.1                1.5               0.2
4                5.0               3.6                1.4               0.2
```
- **DataFrame.tail()**: І навпаки, щоб перевірити останні кілька рядків `DataFrame`, ми використовуємо метод `tail()`:
```python
iris_df.tail()
```
```
     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
145                6.7               3.0                5.2               2.3
146                6.3               2.5                5.0               1.9
147                6.5               3.0                5.2               2.0
148                6.2               3.4                5.4               2.3
149                5.9               3.0                5.1               1.8
```
> **Висновок:** Навіть просто переглянувши метадані про інформацію в DataFrame або перші й останні кілька значень у ньому, ви можете отримати миттєве уявлення про розмір, форму та вміст даних, з якими ви працюєте.

## Робота з відсутніми даними
> **Ціль навчання:** До кінця цього підрозділу ви повинні знати, як замінювати або видаляти відсутні значення з DataFrame.

У більшості випадків набори даних, які ви хочете використовувати (або змушені використовувати), містять відсутні значення. Те, як обробляються відсутні дані, має тонкі компроміси, які можуть вплинути на ваш остаточний аналіз і реальні результати.

Pandas обробляє відсутні значення двома способами. Перший ви вже бачили в попередніх розділах: `NaN`, або Not a Number. Це спеціальне значення, яке є частиною специфікації IEEE для чисел з плаваючою комою, і воно використовується лише для позначення відсутніх значень з плаваючою комою.

Для відсутніх значень, окрім чисел з плаваючою комою, pandas використовує об’єкт Python `None`. Хоча може здатися заплутаним, що ви зіткнетеся з двома різними типами значень, які по суті означають одне й те саме, існують обґрунтовані програмні причини для такого вибору дизайну, і на практиці це дозволяє pandas забезпечити хороший компроміс для більшості випадків. Незважаючи на це, і `None`, і `NaN` мають обмеження, які потрібно враховувати щодо їх використання.

Дізнайтеся більше про `NaN` і `None` у [зошиті](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/4-Data-Science-Lifecycle/15-analyzing/notebook.ipynb)!

- **Виявлення відсутніх значень**: У `pandas` методи `isnull()` і `notnull()` є основними для виявлення відсутніх даних. Обидва повертають булеві маски для ваших даних. Ми будемо використовувати `numpy` для значень `NaN`:
```python
import numpy as np

example1 = pd.Series([0, np.nan, '', None])
example1.isnull()
```
```
0    False
1     True
2    False
3     True
dtype: bool
```
Уважно подивіться на результат. Чи щось вас здивувало? Хоча `0` є арифметичним нулем, це все ж таки цілком допустиме ціле число, і pandas розглядає його як таке. `''` трохи складніше. Хоча ми використовували його в Розділі 1 для представлення порожнього рядка, це все ж таки об’єкт рядка, а не представлення нуля з точки зору pandas.

Тепер давайте перевернемо це й використаємо ці методи так, як ви будете використовувати їх на практиці. Ви можете використовувати булеві маски безпосередньо як індекс ``Series`` або ``DataFrame``, що може бути корисним під час роботи з окремими відсутніми (або наявними) значеннями.

> **Висновок**: Методи `isnull()` і `notnull()` дають схожі результати, коли ви використовуєте їх у `DataFrame`: вони показують результати та індекс цих результатів, що буде надзвичайно корисним під час роботи з вашими даними.

- **Видалення відсутніх значень**: Окрім ідентифікації відсутніх значень, pandas надає зручний спосіб видалення відсутніх значень із `Series` і `DataFrame`. (Особливо для великих наборів даних часто доцільніше просто видалити відсутні [NA] значення з аналізу, ніж обробляти їх іншими способами.) Щоб побачити це в дії, повернемося до `example1`:
```python
example1 = example1.dropna()
example1
```
```
0    0
2     
dtype: object
```
Зверніть увагу, що це має виглядати як ваш результат із `example3[example3.notnull()]`. Різниця тут у тому, що замість індексації за маскованими значеннями `dropna` видалив ці відсутні значення з `Series` `example1`.

Оскільки `DataFrame` має два виміри, він надає більше варіантів для видалення даних.

```python
example2 = pd.DataFrame([[1,      np.nan, 7], 
                         [2,      5,      8], 
                         [np.nan, 6,      9]])
example2
```
|      | 0 | 1 | 2 |
|------|---|---|---|
|0     |1.0|NaN|7  |
|1     |2.0|5.0|8  |
|2     |NaN|6.0|9  |

(Чи помітили ви, що pandas перетворив два стовпці на числа з плаваючою комою, щоб врахувати `NaN`?)

Ви не можете видалити одне значення з `DataFrame`, тому вам доведеться видаляти цілі рядки або стовпці. Залежно від того, що ви робите, вам може знадобитися зробити одне або інше, і pandas надає вам варіанти для обох. Оскільки в науці про дані стовпці зазвичай представляють змінні, а рядки — спостереження, ви частіше видаляєте рядки даних; налаштування за замовчуванням для `dropna()` — видаляти всі рядки, які містять будь-які відсутні значення:

```python
example2.dropna()
```
```
	0	1	2
1	2.0	5.0	8
```
Якщо потрібно, ви можете видалити значення NA зі стовпців. Використовуйте `axis=1`, щоб зробити це:
```python
example2.dropna(axis='columns')
```
```
	2
0	7
1	8
2	9
```
Зверніть увагу, що це може видалити багато даних, які ви, можливо, хочете зберегти, особливо в менших наборах даних. Що, якщо ви хочете видалити лише ті рядки або стовпці, які містять кілька або навіть усі відсутні значення? Ви можете вказати ці налаштування в `dropna` за допомогою параметрів `how` і `thresh`.

За замовчуванням `how='any'` (якщо ви хочете перевірити самостійно або побачити, які інші параметри має метод, запустіть `example4.dropna?` у кодовій комірці). Ви можете вказати `how='all'`, щоб видаляти лише ті рядки або стовпці, які містять усі відсутні значення. Давайте розширимо наш приклад `DataFrame`, щоб побачити це в дії.

```python
example2[3] = np.nan
example2
```
|      |0  |1  |2  |3  |
|------|---|---|---|---|
|0     |1.0|NaN|7  |NaN|
|1     |2.0|5.0|8  |NaN|
|2     |NaN|6.0|9  |NaN|

Параметр `thresh` дає вам більш точний контроль: ви встановлюєте кількість *ненульових* значень, які рядок або стовпець повинен мати, щоб залишитися:
```python
example2.dropna(axis='rows', thresh=3)
```
```
	0	1	2	3
1	2.0	5.0	8	NaN
```
Тут перший і останній рядки були видалені, оскільки вони містять лише два ненульові значення.

- **Заповнення відсутніх значень**: Залежно від вашого набору даних, іноді має більше сенсу заповнити відсутні значення дійсними, ніж видаляти їх. Ви можете використовувати `isnull`, щоб зробити це на місці, але це може бути трудомістким, особливо якщо у вас багато значень для заповнення. Оскільки це дуже поширене завдання в науці про дані, pandas надає `fillna`, який повертає копію `Series` або `DataFrame` із заміненими відсутніми значеннями на ваш вибір. Давайте створимо ще один приклад `Series`, щоб побачити, як це працює на практиці.
```python
example3 = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
example3
```
```
a    1.0
b    NaN
c    2.0
d    NaN
e    3.0
dtype: float64
```
Ви можете заповнити всі відсутні значення одним значенням, наприклад `0`:
```python
example3.fillna(0)
```
```
a    1.0
b    0.0
c    2.0
d    0.0
e    3.0
dtype: float64
```
Ви можете **заповнити вперед** відсутні значення, тобто використовувати останнє дійсне значення для заповнення відсутнього:
```python
example3.fillna(method='ffill')
```
```
a    1.0
b    1.0
c    2.0
d    2.0
e    3.0
dtype: float64
```
Ви також можете **заповнити назад**, щоб поширити наступне дійсне значення назад для заповнення відсутнього:
```python
example3.fillna(method='bfill')
```
```
a    1.0
b    2.0
c    2.0
d    3.0
e    3.0
dtype: float64
```
Як ви могли здогадатися, це працює так само з `DataFrame`, але ви також можете вказати `axis`, уздовж якого потрібно заповнити відсутні значення. Використовуючи раніше використаний `example2` знову:
```python
example2.fillna(method='ffill', axis=1)
```
```
	0	1	2	3
0	1.0	1.0	7.0	7.0
1	2.0	5.0	8.0	8.0
2	NaN	6.0	9.0	9.0
```
Зверніть увагу, що коли попереднє значення недоступне для заповнення вперед, відсутнє значення залишається.
> **Основна думка:** Існує багато способів впоратися з відсутніми значеннями у ваших наборах даних. Конкретна стратегія, яку ви обираєте (видалення, заміна або навіть спосіб заміни), повинна залежати від особливостей даних. Ви краще зрозумієте, як працювати з відсутніми значеннями, чим більше ви будете взаємодіяти з наборами даних.

## Видалення дубльованих даних

> **Ціль навчання:** До кінця цього підрозділу ви повинні впевнено визначати та видаляти дубльовані значення з DataFrame.

Окрім відсутніх даних, у реальних наборах даних ви часто зустрічатимете дубльовані дані. На щастя, `pandas` пропонує простий спосіб виявлення та видалення дубльованих записів.

- **Визначення дубльованих значень: `duplicated`**: Ви можете легко знайти дубльовані значення за допомогою методу `duplicated` у pandas, який повертає булеву маску, що вказує, чи є запис у `DataFrame` дубльованим попереднім. Давайте створимо ще один приклад `DataFrame`, щоб побачити це в дії.
```python
example4 = pd.DataFrame({'letters': ['A','B'] * 2 + ['B'],
                         'numbers': [1, 2, 1, 3, 3]})
example4
```
|      |letters|numbers|
|------|-------|-------|
|0     |A      |1      |
|1     |B      |2      |
|2     |A      |1      |
|3     |B      |3      |
|4     |B      |3      |

```python
example4.duplicated()
```
```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```
- **Видалення дубльованих значень: `drop_duplicates`:** просто повертає копію даних, для яких всі значення `duplicated` є `False`:
```python
example4.drop_duplicates()
```
```
	letters	numbers
0	A	1
1	B	2
3	B	3
```
Методи `duplicated` і `drop_duplicates` за замовчуванням враховують всі стовпці, але ви можете вказати, щоб вони перевіряли лише підмножину стовпців у вашому `DataFrame`:
```python
example4.drop_duplicates(['letters'])
```
```
letters	numbers
0	A	1
1	B	2
```

> **Основна думка:** Видалення дубльованих даних є важливою частиною майже кожного проєкту з аналізу даних. Дубльовані дані можуть змінити результати ваших аналізів і надати вам неточні результати!


## 🚀 Виклик

Всі обговорені матеріали доступні у [Jupyter Notebook](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/2-Working-With-Data/08-data-preparation/notebook.ipynb). Крім того, після кожного розділу є вправи — спробуйте їх виконати!

## [Тест після лекції](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/15)



## Огляд і самостійне навчання

Існує багато способів дослідження та підходів до підготовки ваших даних для аналізу та моделювання, а очищення даних є важливим етапом, який потребує практичного досвіду. Спробуйте ці виклики на Kaggle, щоб дослідити техніки, які не були охоплені в цьому уроці.

- [Виклик з очищення даних: Парсинг дат](https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/)

- [Виклик з очищення даних: Масштабування та нормалізація даних](https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data)


## Завдання

[Оцінка даних з форми](assignment.md)

---

**Відмова від відповідальності**:  
Цей документ було перекладено за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, звертаємо вашу увагу, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ мовою оригіналу слід вважати авторитетним джерелом. Для критично важливої інформації рекомендується професійний переклад людиною. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникли внаслідок використання цього перекладу.